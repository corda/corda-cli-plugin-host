plugins {
    id 'base'
}

// here we define the tasks which will build the plugins in the subprojects
subprojects { subProject ->
    // we have to apply the gradle jvm plugin, because it provides the jar and build tasks
    apply plugin: 'org.jetbrains.kotlin.jvm'

    // the plugin task will put the files into a jar file with the correct manifest
    def plugin = tasks.register('plugin', Jar) {

        duplicatesStrategy = DuplicatesStrategy.EXCLUDE

        archiveBaseName = "plugin-${subProject.pluginId}"

        var commitId = com.gradle.Utils.execAndGetStdOut "git", "rev-parse", "--verify", "HEAD"

        manifest {
            attributes['Plugin-Class'] = subProject.pluginClass
            attributes["Plugin-Name"] = subProject.pluginId
            attributes['Plugin-Id'] = subProject.pluginId
            attributes['Plugin-Version'] = archiveVersion
            attributes['Plugin-Provider'] = subProject.pluginProvider
            attributes['Plugin-Description'] = subProject.pluginDescription
            attributes["Plugin-Git-Commit"] = "$commitId"
        }

        from sourceSets.main.output

        dependsOn configurations.runtimeClasspath
        from {
            configurations.runtimeClasspath.collect { zipTree(it) }
        } {
            exclude "META-INF/*.SF"
            exclude "META-INF/*.DSA"
            exclude "META-INF/*.RSA"
            exclude "module-info.class"
            exclude "META-INF/versions/*/module-info.class"

            duplicatesStrategy = DuplicatesStrategy.EXCLUDE
        }
    }

    // the assemblePlugin will copy the zip file into the common plugins directory
    tasks.register('assemblePlugin', Copy) {
        from plugin
        into pluginsDir
    }

    artifacts {
        archives plugin
    }
}

def assemblePlugins = tasks.register('assemblePlugins', Copy) {
    dependsOn(subprojects.collect { it.tasks.named('assemblePlugin') })
}

tasks.named('assemble') {
    dependsOn assemblePlugins
}
